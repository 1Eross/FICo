from fastapi import FastAPI
from enum import Enum
import uvicorn
from operation import Operation
from user import User
#get = получить с сервера, post = поместить на сервер, delete = удалить с сервера, put = изменение на сервере. 
app = FastAPI()


#добавление операции
@app.post("/add_operation")
async def add_operation(account_id: int, user_id: int, category_id: int, currency_id: int, incoming: bool, amount: int, operetion_date: str,description: str):
    #answer = 
    pass
#удаление операции
#добавление кошелька 
#удаление кошелька
#вернуть все операции пользователя для статистики












class ModelName(str, Enum):
    apple = "apple"
    watermellon = "watermellon"
    grape = "grape"


# path params

@app.get("/foo0/{my_key}")
async def read_item(my_key):
    return {'message': my_key}

#type notation
@app.get("/foo1/{my_key}")
async def read_item(my_key: int):
    return {'message': my_key, "descrpition": "generated by Logic"}





#predefined params with ENUM class
# @app.get("/foo2/{model_name}")
# async def read_item(model_name: ModelName):
#     if model_name.value == "apple":
#         return{"Position": model_name, "Cost": "15$"}
#     elif model_name is ModelName.watermellon:
#         return{"Position": model_name, "Cost": "20$"}
#     else:
#         return{"Position": model_name, "Cost": "30$"}
    
# #file path
# @app.get("/foo3/{filepath: path}")
# async def read_item(filepath: str):
#     return {"filepath": filepath}

# #Querry tools
# #

# fake_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# #get with args
# @app.get("/foo4/")
# async def read_item(skip: int = 0, limit: int = 10):
#     return fake_db[skip : skip + limit]

# #get with additional params
# @app.get("/foo5/{item_id}")
# async def read_item(item_id: str, q: str | None = None):
#     if q:
#         return {"item_id": item_id, "q": q}
#     return {"item_id": item_id.capitalize()}

# ##Best practice for RESTful API design is that path params
# # are used to identify a specific resource or resources,
# # while query parameters are used to sort/filter those resources.

# #few path and querry params in a row
# @app.get("/users/{user_id}/items/{item_id}")
# async def read_user_item(
#     user_id: int, item_id: str, q: str | None = None, short: bool = False):
#     item = {"item_id": item_id, "owner_id": user_id}
#     if q:
#         item.update({"q": q})
#     if not short:
#         item.update(
#             {"description": "This is an amazing item that has a long description"}
#         )
#     return item

